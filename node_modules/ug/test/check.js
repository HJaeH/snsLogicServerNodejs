'use strict';

const UG = require('../module.js');

let graph = new UG.Graph();
// graph.nodes('node').find('A').edges.forEach(function (edge, index) {

graph.nodes('node').createIndex('name');

graph.createNode('node', {name: 'A'});
graph.createNode('node', {name: 'B'});

graph.createNode('node', {name: 'a'});
graph.createNode('node', {name: 'b'});

graph.createEdge('edge').link(
    graph.nodes('node').find('A'),
    graph.nodes('node').find('B'), true
).setDistance(1);


graph.createEdge('edge1').link(
    graph.nodes('node').find('a'),
    graph.nodes('node').find('A'), false
).setDistance(1);
graph.createEdge('edge1').link(
    graph.nodes('node').find('a'),
    graph.nodes('node').find('B'), false
).setDistance(1);

graph.createEdge('edge1').link(
    graph.nodes('node').find('b'),
    graph.nodes('node').find('A'), false
).setDistance(1);

graph.createEdge('edge1').link(
    graph.nodes('node').find('b'),
    graph.nodes('node').find('B'), false
).setDistance(1);


graph.createEdge('edge1').link(
    graph.nodes('node').find('b'),
    graph.nodes('node').find('A'), false
).setDistance(1);

graph.createEdge('edge1').link(
    graph.nodes('node').find('b'),
    graph.nodes('node').find('A'), false
).setDistance(1);

/*
graph.createEdge('edge').link(
    graph.nodes('node').find('C'),
    graph.nodes('node').find('Y'), false
).setDistance(0.5);


graph.createEdge('edge').link(
    graph.nodes('node').find('A'),
    graph.nodes('node').find('B'), false
).setDistance(3);

graph.createEdge('edge').link(
    graph.nodes('node').find('A'),
    graph.nodes('node').find('C'), false
).setDistance(1);

graph.createEdge('edge').link(
    graph.nodes('node').find('A'),
    graph.nodes('node').find('D'), false
).setDistance(1);

graph.createEdge('edge').link(
    graph.nodes('node').find('A'),
    graph.nodes('node').find('E'), false
).setDistance(5);


graph.createEdge('edge').link(
    graph.nodes('node').find('A'),
    graph.nodes('node').find('E'), false
).setDistance(0.3);*/
/*

graph.createEdge('edge').link(
    graph.nodes('node').find('C'),
    graph.nodes('node').find('F'), false
).setDistance(1);
*/

/*
console.log(
    graph.trace(
        graph.nodes('node').find('A'),
        graph.nodes('node').find('E')
    ).prettify()
)

console.log('Closest:');

graph.closest(graph.nodes('node').find('A')).map(function(v) {
    console.log(v.distance(), v.end().toString());
});

// Can load from serialized ?

console.log('Serialize and re-run query');

graph.fromJSON(graph.toJSON());

graph.closest(graph.nodes('node').find('A')).map(function(v) {
    console.log(v.distance(), v.end().toString());
});

console.log('get');*/
//

// console.log(graph.nodes('node').find('A'));
// console.log(graph.nodes(']node').find('A').edges.length);


var set = new Set();
var i = 0 ;
graph.nodes('node').find('A').edges.forEach(function (edge, index) {
    // if(edge.inputNode.get('name') != 'A'){
        console.log(graph.nodes('node').find('A').edges.length + '--------');

    if (edge.entity.toString() === 'edge1') {
        console.log(edge.inputNode.get('name'));
        // console.log(edge.inputNode.outputEdges[1].outputNode)
        /*.forEach(function (edge) {*/ // 한 노드를 추가한 유저들 -> 걔들이 팔로우 하는 노드들.
        // edge.outputNode.outputEdges
        /*edge.outputNode.edges.forEach( function(eachEdge){
            console.log(eachEdge.inputNode.get('name'));
            /!*if (eachEdge.entity === 'edge1') {
                // console.log(eachEdge.outputNode.get('name'));
                console.log(eachEdge.entity);
                if (eachEdge.outputNode.get('name') == 'B')
                    i++;
            }*!/
        });*/

    }
});

console.log(i)